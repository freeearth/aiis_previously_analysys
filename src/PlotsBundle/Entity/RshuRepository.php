<?php

namespace PlotsBundle\Entity;


use Doctrine\ORM\EntityRepository;
use Doctrine\DBAL\Driver\Connection;
use PlotsBundle\DoctrineFunctions\TestDQLFunctions;
use Doctrine\DBAL\DriverManager;
use mysqli;
use PDO;
use Exception;
use ErrorException;
/**
 * RshuRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
use PlotsBundle\Classes\Utilites;

class RshuRepository extends EntityRepository
{
    
    public function getF() {
        /*ТАК СОСТАВЛЯЕТСЯ ЗАПРОС К БД, С ПОМОЩЬЮ DQL
         */
        $em = $this->getEntityManager();
        $query = $em->createQuery(
            'SELECT n.f
            FROM PlotsBundle:RshuNew n
            WHERE n.datetime = :time
            ORDER BY n.datetime ASC'
        )->setParameter('time', '2008-05-07 10:52:26');

        $result = $query->getResult();        

        
        return $result;
    }
    
    /*
     * ЗАПРОС МАССИВА МЕТЕОПАРАМЕТРОВ ИЗ БД ДЛЯ ТАБЛИЧНОГО ВЫВОДА И(ИЛИ) excel ФАЙЛА
     * ВХОДНЫЕ ПАРАМЕТРЫ:
     * param_meteo - имя метеопараметра для запроса
     * param_datetime - дата и время начала измерения из БД
     * param_lenght - количество строк запрашиваемого архивного файла в минутах
    */
    public function get_meteo_array_n ($param_meteo,$param_datetime,$param_lenght,$param_discretn) {
            //$query_1 = new MysqliStatement();
            $utilites = new Utilites();
            //ДЛИНА ФАЙЛА В МИНУТАХ
            $lenght=$param_lenght*$param_discretn;
            //ФОРМИРОВАНИЕ ИМЕНИ ИЛИ ПСЕВДОНИМА ДЛЯ ЗАПРОСА ИЗ БД
            $col_name=$utilites::get_count_name($param_meteo);
            //echo $col_name;die;
            $em = $this->getEntityManager();
            
            /*
             * "SELECT un.".$col_name." 
                    FROM PlotsBundle:RshuNew un
                    WHERE un.datetime BETWEEN
                    :dt AND DATE_ADD(:dt,:lengths,'SECOND') GROUP BY un.datetime"
             */
            //запрос к БД с помощью DQL(Doctrine query language)
            $query = $em->createQuery(
                    "SELECT un.".$col_name." 
                    FROM PlotsBundle:RshuNew un
                    WHERE un.datetime BETWEEN
                    :dt AND dateadd(:dt,INTERVAL :lengths SECOND) GROUP BY un.datetime"
            )->setParameters(array(
                                'dt' => $param_datetime,
                                'lengths' => $param_lenght,
                                ));
            $result[]=$query->getArrayResult();
            
            //$i=0;            
            //время начала запрашиваемых данных в формате timestamp
            //$curr_timestamp_begin = strtotime($param_datetime);
            //время окончания измерения запрашиваемых данных в формате timestamp
            //$curr_timestamp_end = strtotime($param_datetime + $param_lenght);
            
            /*while (($param_discretn*10)*$i!==$param_lenght*10) {          
                $query = $em->createQuery(
                        "SELECT un.".$col_name." 
                        FROM PlotsBundle:RshuNew un
                        WHERE un.datetime=dateadd(:dt,INTERVAL :lengths SECOND) GROUP BY un.datetime"
                )->setParameters(array(
                                    'dt' => $param_datetime,
                                    'lengths' => ($param_discretn*10)*$i,
                                    ));
                $result[]=$query->getResult();
                $i++;
            }
            /*
             * Аналог offset в DQL производится с помощью сочетания
             * ->setMaxResults(число результирующих элементов);
            /* ->setFirstResult(с какой записи возвращать значение элемента);
             */
            /*
            $k = 0;
            //TODO:: Добавить проверку на число возвращаемых записей
            for ($i=0;$i<$param_lenght;$i++) {
                $query
                        ->setMaxResults(1)
                        ->setFirstResult($k);
                $result[]=$query->getResult();
                $k = $k + $param_discretn;
            }*/
            //$em_1 = $this->getEntityManager();
            //$em_1->createNativeQuery($sql, $rsm);
            return $result;
        }
        
        /*
     * ЗАПРОС МАССИВА МЕТЕОПАРАМЕТРОВ ИЗ БД ДЛЯ ТАБЛИЧНОГО ВЫВОДА И(ИЛИ) excel ФАЙЛА
     * ВХОДНЫЕ ПАРАМЕТРЫ:
     * param_meteo - имя метеопараметра для запроса
     * param_datetime - дата и время начала измерения из БД
     * param_lenght - количество строк запрашиваемого архивного файла в минутах
    */
    public static function get_meteo_array_1 ($param_meteo,$param_datetime,$param_lenght,$param_discretn) {
        if ($param_meteo==="N") {
            return;
        }
        else {
            /*
             * Вызов mysqli из класса!
             * Это неправильный подход!
             * TODO::через DBAL
             */
            $mysql_host = "localhost";
            $mysql_db = "*********";
            $mysql_user = "root";
            $mysql_password = "*********";
            $mysqli = new mysqli($mysql_host, $mysql_user, $mysql_password, $mysql_db);
            //ДЛИНА ФАЙЛА В МИНУТАХ
            $lenght=$param_lenght*10;//т.к. в форме ед.изм - 10 секунд
            //ФОРМИРОВАНИЕ ИМЕНИ ИЛИ ПСЕВДОНИМА ДЛЯ ЗАПРОСА ИЗ БД
            $utilites = new Utilites();
            $col_name=$utilites::get_count_name($param_meteo);
            /*
             * ТЕСТ ЗАПРОСА ИЗ БД
             * echo "SELECT $col_name FROM `meteo` WHERE `Timestamp` BETWEEN
               '$param_datetime' AND '$param_datetime' +INTERVAL $lenght MINUTE GROUP BY `Timestamp`";
             /* 
             */
            $db_statement = "SELECT $col_name FROM `rshu_new` WHERE `datetime` BETWEEN
                ? AND ? +INTERVAL ? SECOND GROUP BY `datetime`";
            $stmt = $mysqli->prepare($db_statement);
            if (!$stmt) {
                echo "error!";
                /*ДЛЯ ОТЛАДКИ РАСКОММЕНТИРОВАТЬ - ПОЛУЧИТЬ ОШИБКИ
                *
                 print_r($mysqli->error_list);die;
                 /* 
                 */
                die;
            }
            if ($stmt) {
                //БИНДИМ 2 СТРОКОВЫХ ПАРАМЕТРА(s) -- МЕТЕОПАРАМЕТР И ДАТУ НАЧАЛА ИЗМЕРЕНИЯ
                $stmt->bind_param("ssi",$param_datetime,$param_datetime,$lenght);
                $stmt->execute();
                $stmt->bind_result($result_param);
                if ($stmt->field_count) {
                    //ПАРАМЕТР, ДЛЯ СДВИГА НА ОПРЕДЕЛЁННОЕ ЧИСЛО РЕЗУЛЬТИРУЮЩИХ ЗАПИСЕЙ == ДИСКРЕТНОСТЬ АРХИВНОГО ФАЙЛА
                    $k = -$param_discretn;
                    //$param_lenght>$stmt->field_count?$param_lenght=$stmt->field_count:1;
                    $strok_rez=0;
                    $result = array();
                    for ($i=0;$i<$param_lenght;$i++) {
                        $k = $k + $param_discretn;
                        //перемещаемся на k строк вперёд, с учётом абсолютной(установленной на станции) дискретности измерений
                        $stmt->data_seek($k);
                        //$stmt->fetch(PDO::FETCH_ASSOC, PDO::FETCH_ORI_ABS, $k);
                        $stmt->store_result();
                        $stmt->fetch();
                        //метка конца ряда
                        $label_end=$stmt->fetch();
                        if ($label_end==NULL) break;
                        //ПОСЧИТАЕМ КОЛИЧЕСТВО ЗАПИСЕЙ, КОТОРЫЕ ПОЛУЧИМ В РЕЗУЛЬТАТЕ ЗАПРОСА, НО ТОЛЬКО В ПЕРВОЙ ИТЕРАЦИИ
                        if ($i==0) {$strok_rez=$stmt->num_rows;}
                        $result[]=$result_param;
                    }
                        $stmt->close();
                        return $result;
                }
                else { return "error";die;}
            }
        }
    }
}

